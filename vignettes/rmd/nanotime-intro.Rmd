---
title: \pkg{nanotime}&#58; A datetime library with nanosecond precision

# Use letters for affiliations
author:
  - name: Dirk Eddelbuettel
    affiliation: 1
  - name: Leonardo Silvestri
    affiliation: 2
address:
  - code: 1
    address: Department of Statistics, University of Illinois, Urbana-Champaign, IL, USA
  - code: 2
    address: Baltimore, MD, USA

# For footer text  TODO(fold into template, allow free form two-authors)
lead_author_surname: Eddelbuettel, Silvestri

# Place DOI URL or CRAN Package URL here
doi: "https://cran.r-project.org/package=nanotime"

# Abstract
abstract: |
  The \pkg{nanotime} package \citep{nanotime2020} provides a coherent set of temporal types
  and functions with nanosecond precision. The types are: point in time, interval 
  (which may have an open or closed start/end), period (a human representation of time, 
  such as day, month, etc.), and duration. Of particular interest are the set
  and arithmetic operations defined on these types as well as the fact that 
  all functionality is designed to correctly handle instances across different 
  time zones. Because these temporal types are based on R built-in types, most functions 
  have an efficient implementation and the types are suitable for use in `data.frame` 
  and `data.table`. `nanotime` is also a better choice than the native `POSIXct` 
  in most cases where fractional seconds are needed.

# Font size of the document, values of 9pt (default), 10pt, 11pt and 12pt
fontsize: 9pt

# Optional: Force one-column layout, default is two-column
one_column: true

# Optional: Enables lineno mode, but only if one_column mode is also true
#lineno: true

# Optional: Enable one-sided layout, default is two-sided
#one_sided: true

# Optional: Enable section numbering, default is unnumbered
#numbersections: true

# Optional: Specify the depth of section number, default is 5
#secnumdepth: 5

# Optional: Skip inserting final break between acknowledgements, default is false
skip_final_break: true

# Optional: Bibliography
bibliography: nanotime-intro

# Optional: Enable a 'Draft' watermark on the document
watermark: false

# Customize footer, eg by referencing the vignette
footer_contents: "nanotime Vignette"

# Produce a pinp document
output:
  pinp::pinp:
    collapse: true
    keep_tex: false

header-includes: >
  \newcommand{\proglang}[1]{\textsf{#1}}
  \newcommand{\pkg}[1]{\textbf{#1}}

# Required: Vignette metadata for inclusion in a package.
vignette: >
  %\VignetteIndexEntry{Introduction to nanotime}
  %\VignetteKeywords{anytime, date, datetime, conversion}
  %\VignettePackage{anytime}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---

```{r initialsetup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE)
library(bit64)
library(nanotime)
library(data.table)
```


# Implementation of the temporal types

All new types are implemented using one or more signed 64-bit integers. This avoids the floating
point issues associated with `POSIXct` and allows for exact representation of nanosecond datetimes
in the approximative range of years 1386 to 2554, which is large enough for most applications. It
also allows for exact arithmetic and comparison.

# Time zones

Time zones are only needed in two cases. First, for representation, because of course the same time
is represented differently in different time zones, and secondly, for operations with calendar time,
since a year or a day has a different length depending on its location in time and depending in
which time zone it is considered.

To avoid all ambiguity, a time zone is never associated as an attribute with any of the temporal
types defined in the \pkg{nanotime} package. Any operation where a time zone is needed in order to
make sense of it requires an explicit specification.

# Temporal types

The \pkg{nanotime} package implements four temporal types: time (`nanotime`), interval (`nanoival`),
duration (`nanoduration`) and period (`nanoperiod`). This set of types seems to have become the
consensus for various implementations. It is the set chosen by _Joda Time_ [see @Joda2019], the
\pkg{lubridate} package \citep{lubridate2011} (without nanosecond resolution), and a similar set
(minus the interval type) is chosen by the latest Java Date and Time implementation [see @Java2014].

## nanotime

`nanotime` is a point in time with nanosecond resolution. It is implemented as an S4 class
containing the type `integer64` from the _bit64_ package [see @bit642015] and represents an offset
in nanoseconds from 1970-01-01 UTC. It does not have an associated time zone, but can be displayed
in any desired time zone with the `format` or `print` functions. Finally, it uses the POSIX
definition of time, usually referred to as _POSIX time_ or _UNIX time_ [see @POSIX2016]. This is a
representation suitable for many purposes.

It can be constructed either from an `integer64` or from a `character`:

```{r}
as.nanotime(as.integer64("1580274000000000000"))
as.nanotime("2020-01-29 13:12:00.000000001 America/New_York")
as.nanotime("2020-01-29 13:12:00.000000001-05:00")
```
Short forms are also allowed:

```{r}
as.nanotime("2020-01-29 Europe/London")
as.nanotime("2020-01-29 12:01:01 Africa/Lagos")
as.nanotime("2020-01-29 12:01:01.001 America/Tegucigalpa")
```


## nanoival

A `nanoival` is an interval in time defined by two `nanotime`, the first one being the start time
and the second one the end time, and by two `logical` that determine if the interval start and end
are open (`TRUE`) or closed (`FALSE`), i.e. if the start and end of the interval are excluded
(`TRUE`) or included (`FALSE`) in the interval.

A `nanoival` can either be constructed with two `nanotime` and two `logical` or it can be
constructed from a `character` string. The string format uses the '-' and '+' signs at the beginning
and end to indicate if the interval start and end are open or closed. By default an interval has a
closed start and an open end.

```{r}
as.nanoival("-2009-01-01 13:12:00 America/New_York -> 2009-02-01 15:11:03 America/New_York+")

start <- nanotime("2009-01-01 13:12:00 America/New_York")
end   <- nanotime("2009-02-01 15:11:00 America/New_York")

nanoival(start, end)                   # by default sopen=F,eopen=T
nanoival(start, end, sopen=FALSE, eopen=TRUE)
```

Accessors for `nanoival` are provided:

```{r, nanoival_accessors}
ival  <- as.nanoival("-2009-01-01 UTC -> 2009-02-01 UTC+")
nanoival.start(ival)
nanoival.end(ival)
nanoival.sopen(ival)
nanoival.eopen(ival)
```

## nanoduration

A `nanoduration` is simply a count of nanoseconds, which may be negative.

```{r}
nanoduration(hours=1, minutes=1, seconds=1, nanoseconds=1)
as.nanoduration("00:00:01")
as.nanoduration("-00:00:01")
as.nanoduration("100:00:00")
as.nanoduration("00:00:00.000_000_001")
```

## nanoperiod

A `nanoperiod` represents the calendar or "business" view of a duration with the concepts of month
and day. The exact duration of a period is unknown until it is anchored to a point in time and
associated with a time zone, first because a month has variable length and secondly because it might
span a daylight saving time change.

`nanoperiod` is composed of two parts: a months/days part and a duration. Note that these components
may have opposite signs.

For convenience, the constructor syntax allows specifying years and weeks, but they are converted to
their representation in months/days.

```{r}
as.nanoperiod("1y1m1w1d/01:01:01.000_000_001")
nanoperiod(months=13, days=-1, duration="01:00:00")
```

Accessors for `nanoperiod` components are provided:

```{r}
ones <- as.nanoperiod("1y1m1w1d/01:01:01.000_000_001")
nanoperiod.month(ones)
nanoperiod.day(ones)
nanoperiod.nanoduration(ones)
```

# Set operations

The set operations `intersect`, `union` and `setdiff` are provided for a more rigorous handling of
temporal types. Additionally, `intersect` and `setiff` have counterpart functions `intersect.idx`
and `setdiff.idx` that, instead of computing a new set, return the index of the set. Finally, the
operator `%in%` is overloaded so as to provide a convenient intersection shorthand particularly
suitable for the subsetting of `data.table` time-series.

Here are some examples:

```{r, setops}
ni1 <- c(as.nanoival("+2013-01-01+00:00          -> 2014-01-01+00:00-"),
         as.nanoival("+2015-01-01T12:00:01+00:00 -> 2016-01-01+00:00-"),
         as.nanoival("+2017-01-01+00:00          -> 2018-01-01+00:00-"))
ni2 <-   as.nanoival("-2013-02-02+00:00          -> 2015-06-10+00:00+")
intersect(ni1, ni2)
union(ni1, ni2)         
setdiff(ni1, ni2)
```


# Functions and operations

## Arith

The usual expected arithmetic operations are defined for various types when these make sense. In
particular one can add/subtract a `period` or a `duration` to/from a `nanotime` or a `nanoival` and
multiply and divide `period` and `duration` by a scalar.

```{r, arith}
as.nanotime("2020-03-07 01:03:28 America/Los_Angeles") + 999
as.nanotime("2020-03-07 12:03:28+00:00") + as.nanoduration("24:00:00")
## daylight saving time transition:
plus(as.nanotime("2020-03-07 12:03:28+00:00"), as.nanoperiod("1d"), "America/Los_Angeles")

as.nanoduration("24:00:00")/3
-as.nanoduration("24:00:00")
```

## Compare

Compare operations are mostly straightforward except maybe for `nanoival` which is ordered by its
start `nanotime`. If both starts are equal, a closed start comes before an open start. If both
`sopen` are the same, then the comparison happens on the end of the `nanotime`, with a shorter
interval coming before a longer one. `nanoperiod` do not have a meaningful ordering and therefore
remain unordered.

```{r, compare}
as.nanoival("+2020-04-03 00:12:00 UTC -> 2020-04-04 00:12:00 UTC-") <
    as.nanoival("-2020-04-03 00:12:00 UTC -> 2020-04-04 00:12:00 UTC-")
nanotime(1) <= nanotime(2)
as.nanoduration(1) > as.nanoduration(2)
```

## Sequence generation

Sequence generation is provided for `nanotime` and `nanoival`. The increment can either be a
`nanoduration` or a `nanoperiod`. Since a period is sensitive to the time zone in which the operation
takes place, the additional `tz` argument must be provided to `seq`.

```{r, seq_generation}
seq(nanotime("2020-03-28+00:00"), by=as.nanoduration("24:00:00"), length.out=3)
seq(nanotime("2020-03-28+00:00"), by=as.nanoperiod("1d"), length.out=3, tz="Europe/London")

ival <- as.nanoival("+2020-03-28T13:00:00+00:00 -> 2020-03-28T15:00:00+00:00-")
print(seq(ival, by=as.nanoperiod("1m"), length.out=3, tz="Europe/London"), tz="Europe/London")

```

Note that `nanoperiod` is time zone correct, even on the rare hourly events where a transition
occurs from a time zone offset with an hourly difference to a time zone offset with a half-hourly
difference.

``` {r}
print(seq(as.nanotime("2006-04-14 22:00:00 Asia/Colombo"),
          by=as.nanoperiod("01:00:00"),
          length.out=4,
          tz="Asia/Colombo"),
      tz="Asia/Colombo")
```

## Year/month/day

Utilities are provided for getting in numerical format the day of the week (`nano_wday`), the day of
the month (`nano_mday`), the month (`nano_month`) and the year (`nano_year`) from a given
`nanotime`. Remember that a time zone is never associated with a `nanotime` and therefore, to have
meaning, all the functions take as second argument the time zone for the computation. Note that the
convention for the day of the week is a count from 0 to 6, with 0 falling on Sunday.

```{r, year_month_day}
tm  <- as.nanotime("2019-12-31 20:00:00", tz="UTC")
nano_wday(tm, "Australia/Melbourne")
nano_wday(tm, "America/New_York")
nano_mday(tm, "Africa/Nairobi")
nano_month(tm, "Indian/Reunion")
nano_year(tm, "Asia/Irkutsk")
```

## Rounding operations

The functions `nano_floor` and `nano_ceiling` are provided in order to perform rounding to an
arbitrary precision. An `origin` argument of type `nanotime` can be optionally specified so there is
full control over the reference chosen for the rounding.

These functions are also to be understood in the context of vectors of `nanotime` where the
precision defines a grid interval. These functions will pick a reasonable reference for the
alignment. In particular, when using a `nanoperiod`, the functions will check if a precision is a
multiple of a larger unit. If so, the rounding will happen with the larger unit as origin. For
instance, if the precision is 6 hours - a multiple of a day - the rounding will be performed in such
a way as to align the vector with a day, i.e. the rounding will be done at hours 0, 6, 12 and 18. On
the other hand, if the origin is explicitly specified, then it is this value that will be taken as
starting point for the rounding. For instance, if the origin is set to `2020-04-27 23:57:04` then
the rounding will be done at 23:57:04, 05:57:04, 11:57:04 and 17:57:04.

```{r, rounding ops}
nano_floor(as.nanotime("2020-04-27 23:57:04.123456678 UTC"), as.nanoduration("00:00:00.001"))
nano_ceiling(as.nanotime("2020-04-27 23:57:04.123456678 UTC"), as.nanoduration("00:00:00.001"))

nano_floor(as.nanotime("2020-04-27 23:57:04 UTC"), as.nanoperiod("06:00:00"), tz="UTC")
nano_ceiling(as.nanotime("2020-04-27 23:57:04 UTC"), as.nanoperiod("06:00:00"), tz="UTC")

nano_floor(as.nanotime("2020-04-27 23:57:04 America/New_York"), as.nanoperiod("1m"), tz="America/New_York")
nano_ceiling(as.nanotime("2020-04-27 23:57:04 America/New_York"), as.nanoperiod("1m"), tz="America/New_York")
```

# Use with data.frame and data.table 


All the new types are compatible with `data.frame` and `data.table`. By having an ordered `nanotime`
column it is thus easy to define a time-series. One can then use `nanoival` subsetting.

```{r, data.table}

idx <- seq(nanotime("2020-04-02+00:00"), by=as.nanoperiod("1d"), length.out=20, tz="UTC")
dt <- data.table(idx, v1=1:20, v2=c(TRUE, FALSE))
ival <- as.nanoival(c("+2020-04-05 UTC -> 2020-04-07 UTC+",
                      "+2020-04-15 UTC -> 2020-04-17 UTC+"))
dt[idx %in% ival]

```

With the rounding functions, it is possible to perform aggregations on `data.table` instances:

```{r, aggregations}
idx <- seq(as.nanotime("2020-03-08 UTC"), as.nanotime("2020-03-10 UTC"), by=as.nanoduration("00:01:00"))
dt <-  data.table(idx, a=1:length(idx))
dt[, .(mean=mean(a)), by=nano_ceiling(idx, as.nanoduration("06:00:00"))]
```


# Input and output Format

## nanotime

The input and output format is by default "%Y-%m-%dT%H:%M:%EXS%Ez" where the 'X' specifies a
variable number of digits for the nanosecond portion. When no overriding format is defined, the
output will include only the relevant nanotime precision for the vector without right 0 padding; for
example:

```
2020-12-12T00:00:00+00:00 which is equivalent to 2020-12-12T00:00:00.000000000+00:00
2020-12-12T00:00:00.123+00:00 which is equivalent to 2020-12-12T00:00:00.123000000+00:00
2020-12-12T00:00:00.123456+00:00 which is equivalent to 2020-12-12T00:00:00.123456000+00:00
2020-12-12T00:00:00.123456789+00:00
```

When no overriding format is defined (see ...)  the parsing has some flexibility and the time
portion can be omitted. Additionally, the separator `'_'` can be used to separate nanosecond groups
of 3. So the following examples will parse correctly:

```
2020-04-03
2020-04-03 12:23:00
2020-04-03 12:23:00.1
2020-04-03 12:23:00.123
2020-04-03 12:23:00.123356789
2020-04-03 12:23:00.123_356_789
```

Date separators can be `' '`, `'-'` and `'/'` whereas the separator between date and time can be
`'T`' or `' '`:

```
2020 04 03
2020/04/03
2020-04-03T12:23:00
```

## nanoival

The format is based on `nanotime` because a `nanoival` is composed of a `nanotime` start and end as
well as two booleans that indicate if the boundaries of the interval are open or closed. This open
and closed is indicated by prefixing and postfixing with the the characters `'-'` and `'+'`. The
start and end are separated by `'->'`. Here are a few examples:

```
+2020-12-12 UTC -> 2020-12-13 UTC-
-2020-12-12T00:00:01.123 America/New_York -> 2020-12-14+00:00+
```

## nanoduration

The format is immutable and the same as the hour/minute/second/nanosecond portion of a `nanotime`;
for example:

```
12:23:00
12:23:00.1
12:23:00.123
12:23:00.123356789
12:23:00.123_356_789
```

## nanoperiod

The format is here too immutable and is composed of two parts, a month/day part and a `nanoduration`
part that are separated by `'/'`. In input, years, months, weeks and days are specified with a
signed integer following, respectively by the letters `'y'`,`'m'`,`'w'`,`'d'`. The `nanoduration`
that composes the second part is specified like for a standalone `nanoduration`. Each of these two
parts is optional. In output, only months and days are specified as years can be expressed as 12
months and weeks as 7 days. Here are some examples:

```
1y1m1w1d/00:00:00.123 which is, in output, simplified to 13m8d/00:00:00.123
-2y
00:00:00.123
12m1s/01:00:00
```

# Technical Details

All four new types in this package are built with S4 classes containing an R primitive type that is
then reinterpreted. `nanotime` and `duration` are (indirectly) based on `double` via the type
`integer64` from the \pkg{bit64} package \citep{bit642015}, whereas `nanoival` and `period` are
based on `complex`, which allows the storage of 128 bits.

All the heavy lifting is done at C++ level using the \pkg{Rcpp} package \citep{CRAN:Rcpp}.


# Performance

The `as.POSIXct` function in R provides a useful baseline as it is also implemented in compiled
code. The `fastPOSIXct` function from the \pkg{fasttime} package \citep{CRAN:fasttime} excels at
converting one (and only one) input format _fast_ to a (UTC-only) datetime object. A simple
benchmark converting 100 input strings 10,000 times shows that the `nanotime` constructor is much
closer to the optimal `fastPOSIXct` (see Table \ref{tab:speed}).


```{r knitr_speed, echo=FALSE}
df <- read.table(stringsAsFactors=FALSE, text="
                     test replications elapsed relative
3             as.nanotime        10000   0.366    3.211
5 as.nanotime_with_format        10000   0.487    4.272
4     as.nanotime_with_tz        10000   0.490    4.298
1              as.POSIXct        10000   6.137   53.833
2             fastPOSIXct        10000   0.114    1.000
")
knitr::kable(df, "latex", booktabs=TRUE, row.names=FALSE,
             caption="\\label{tab:speed}Comparison of as.nanotime, base R and fasttime")
```

# Summary

We describe the \pkg{nanotime} package which offers a coherent set of types and operations with
nanosecond precision.

We show that the \pkg{nanotime} package provides the building blocks to build more complicated and
interesting functions, in particular within the context of `data.table` time-series.

# Appendix

The benchmark results shown in table \ref{tab:speed} are based on the code included below, and
obtained via execution under R version 3.6.3 running under Ubuntu 20.04 with Linux kernel 5.4.0-25
on an Intel Xeon E-2176M CPU.

``` {r}
library(nanotime)
library(rbenchmark)
library(fasttime)


x_posixct       <- rep("2020-03-19 22:55:23", 100)
x_nanotime      <- rep("2020-03-19 22:55:23.000000001+00:00", 100)
x_nanotime_tz   <- rep("2020-03-19 22:55:23.000000001 America/New_York", 100)
x_nanotime_cctz <- rep("03-19-2020 22:55:23.000000001+00:00", 100)

benchmark(
    "as.POSIXct" = { x <- as.POSIXct(x_posixct) },
    "fastPOSIXct" = { x <- fastPOSIXct(x_posixct) },
    "as.nanotime" = { x <- as.nanotime(x_nanotime) },
    "as.nanotime with tz" = { x <- as.nanotime(x_nanotime_tz) },
    "as.nanotime with format" = { x <- as.nanotime(x_nanotime_tz, format="%m-%d-%YT%H:%M:%E9S%Ez") },
    replications = 10000,
    columns = c("test", "replications", "elapsed", "relative"))
```
